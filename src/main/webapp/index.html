<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" id="viewportMeta"
              content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
        <title>Map Viewer</title>
        <link rel="icon" type="image/png" href="jnodes.png">
        <style>
            html, body {
                margin: 0;
                padding: 0;
                height: 100%;
                width: 100%;
                overflow: hidden;
                background: #111;
                color: #eee;
                font-family: sans-serif;
            }

            /* ================= LIST PAGE ================= */
            #listPage {
                height: 100%;
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #listCard {
                width: min(760px, calc(100vw - 40px));
                max-height: min(80vh, 680px);
                overflow: auto;
                background: rgba(0, 0, 0, 0.55);
                border: 1px solid rgba(255, 255, 255, 0.10);
                border-radius: 16px;
                padding: 18px 18px 14px;
                backdrop-filter: blur(10px);
                box-shadow: 0 14px 40px rgba(0,0,0,0.35);
            }

            #listHeader {
                display: flex;
                align-items: baseline;
                justify-content: space-between;
                gap: 12px;
                margin-bottom: 12px;
            }

            #listHeader .title {
                font-size: 1.05em;
                color: #e8e8e8;
            }

            #listHeader .subtitle {
                font-size: 0.85em;
                color: #aaa;
                white-space: nowrap;
            }

            #mapsGrid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 10px;
            }

            .mapTile {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px;
                border-radius: 12px;
                cursor: pointer;
                border: 1px solid rgba(255,255,255,0.08);
                background: rgba(255,255,255,0.04);
                transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
            }

            .mapTile:hover {
                transform: translateY(-1px);
                background: rgba(255,255,255,0.06);
                border-color: rgba(0,224,198,0.28);
            }

            .mapName {
                font-size: 0.95em;
                color: #f0f0f0;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            .openHint {
                font-size: 0.8em;
                color: #00e0c6;
                opacity: 0.9;
            }

            #listStatus {
                margin-top: 12px;
                font-size: 0.9em;
                color: #00e0c6;
                background: rgba(0, 0, 0, 0.35);
                padding: 8px 10px;
                border-radius: 10px;
                display: inline-block;
            }

            /* ================= MAP PAGE ================= */
            #mapPage {
                display: none;
                height: 100dvh;
                width: 100vw;
            }

            #container {
                width: 100vw;
                height: 100dvh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #111;
            }

            #mapCanvas {
                background: #222;
                touch-action: none;
                display: block;
            }

            #status {
                position: fixed;
                bottom: 8px;
                left: 8px;
                font-size: 0.9em;
                color: #00e0c6;
                background: rgba(0, 0, 0, 0.45);
                padding: 6px 10px;
                border-radius: 6px;
                backdrop-filter: blur(4px);
            }

            /* ================= HOME ICON ================= */
            #homeBtn {
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 30;
                width: 38px;
                height: 38px;
                border-radius: 12px;
                background: rgba(0, 0, 0, 0.55);
                border: 1px solid rgba(255, 255, 255, 0.10);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                backdrop-filter: blur(8px);
                box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            }

            .homeIcon {
                position: relative;
                width: 16px;
                height: 16px;
            }

            .homeIcon::before {
                content: "";
                position: absolute;
                left: 50%;
                top: 1px;
                width: 10px;
                height: 10px;
                border-left: 2px solid #eee;
                border-top: 2px solid #eee;
                transform: translateX(-50%) rotate(45deg);
            }

            .homeIcon::after {
                content: "";
                position: absolute;
                left: 50%;
                bottom: 0;
                width: 12px;
                height: 9px;
                border: 2px solid #eee;
                border-top: none;
                transform: translateX(-50%);
            }

            #homeBtn:hover .homeIcon::before,
            #homeBtn:hover .homeIcon::after {
                border-color: #00e0c6;
            }
        </style>
    </head>
    <body>
        <!-- LIST MODE -->
        <div id="listPage">
            <div id="listCard">
                <div id="listHeader">
                    <div class="title">Available maps</div>
                    <div class="subtitle">Click a map to open in a new window</div>
                </div>
                <div id="mapsGrid"></div>
                <div id="listStatus">Loading...</div>
            </div>
        </div>

        <!-- MAP MODE -->
        <div id="mapPage">
            <div id="container">
                <canvas id="mapCanvas"></canvas>
            </div>
            <div id="homeBtn" title="Back to map list">
                <span class="homeIcon"></span>
            </div>
            <div id="status">Loading...</div>
        </div>

        <script>
            const IMAGE_ENDPOINT = 'image';
            const LIST_ENDPOINT = 'list';
            const REFRESH_MS = 4000;
            const MAX_ZOOM = 6;

            function getMapParam() {
                return new URL(window.location.href).searchParams.get('map');
            }

            function buildIndex(map) {
                const u = new URL(window.location.href);
                map ? u.searchParams.set('map', map) : u.searchParams.delete('map');
                return u.toString();
            }

            /* -------- LIST MODE -------- */
            async function loadMapList() {
                try {
                    const res = await fetch(LIST_ENDPOINT);
                    const data = await res.json();
                    const maps = data.maps || [];

                    const grid = document.getElementById('mapsGrid');
                    grid.innerHTML = '';

                    maps.forEach(name => {
                        const tile = document.createElement('div');
                        tile.className = 'mapTile';
                        tile.innerHTML = `<div class="mapName">${name}</div><div class="openHint">Open</div>`;
                        tile.onclick = () => window.open(buildIndex(name), '_blank', 'noopener');
                        grid.appendChild(tile);
                    });

                    document.getElementById('listStatus').textContent =
                            maps.length ? `Loaded ${maps.length} map(s)` : 'No maps available';

                } catch (e) {
                    document.getElementById('listStatus').textContent = 'Error loading map list';
                }
            }

            /* -------- MAP MODE -------- */
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const buffer = document.createElement('canvas');
            const bctx = buffer.getContext('2d');
            let mapName = null, timer = null;
            const viewportMeta = document.getElementById('viewportMeta');
            let baseScale = 1;
            let zoom = 1;       // user zoom factor relative to the fitted view
            let offsetX = 0, offsetY = 0;
            const pointers = new Map();
            let pinchStartDist = null, pinchStartZoom = 1;
            let lastPan = null;
            let isInteracting = false;
            let hasUserInteracted = false;
            let pendingImage = null;
            let pendingTimestamp = null;

            function setViewportMode(mode) {
                if (!viewportMeta) return;
                // Disable native page zoom; pinch handled internally on canvas.
                viewportMeta.setAttribute('content',
                    'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');
            }

            function clampZoom(z) {
                return Math.min(MAX_ZOOM, Math.max(1, z));
            }

            function computeBaseScale() {
                if (!buffer.width || !buffer.height) return 1;
                return Math.min(canvas.width / buffer.width, canvas.height / buffer.height);
            }

            function clampOffsets(scale) {
                if (!buffer.width || !buffer.height) return;
                const imgW = buffer.width * scale;
                const imgH = buffer.height * scale;
                const minX = Math.min(0, canvas.width - imgW);
                const maxX = Math.max(0, canvas.width - imgW);
                const minY = Math.min(0, canvas.height - imgH);
                const maxY = Math.max(0, canvas.height - imgH);
                offsetX = Math.min(maxX, Math.max(minX, offsetX));
                offsetY = Math.min(maxY, Math.max(minY, offsetY));
            }

            function currentAnchor(canvasX = canvas.width / 2, canvasY = canvas.height / 2) {
                if (!buffer.width) return { canvasX, canvasY, imgX: 0, imgY: 0 };
                const scale = baseScale * zoom;
                return {
                    canvasX,
                    canvasY,
                    imgX: (canvasX - offsetX) / scale,
                    imgY: (canvasY - offsetY) / scale
                };
            }

            function restoreAnchor(anchor) {
                const scale = baseScale * zoom;
                offsetX = anchor.canvasX - anchor.imgX * scale;
                offsetY = anchor.canvasY - anchor.imgY * scale;
            }

            function draw() {
                if (!buffer.width)
                    return;
                const scale = baseScale * zoom;
                clampOffsets(scale);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
                ctx.drawImage(buffer, 0, 0);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }

            function resize() {
                const shouldCenter = !hasUserInteracted && zoom === 1;
                const anchor = shouldCenter ? null : currentAnchor();
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                baseScale = computeBaseScale();
                zoom = clampZoom(zoom);
                if (shouldCenter && buffer.width) {
                    const fitScale = baseScale * zoom;
                    offsetX = (canvas.width - buffer.width * fitScale) / 2;
                    offsetY = (canvas.height - buffer.height * fitScale) / 2;
                } else if (anchor) {
                    restoreAnchor(anchor);
                }
                draw();
            }

            function applyImage(img, timestamp) {
                const hadImage = buffer.width > 0 && buffer.height > 0;
                const shouldCenter = !hasUserInteracted && zoom === 1;
                const anchor = (!shouldCenter && hadImage) ? currentAnchor() : null;

                buffer.width = img.width;
                buffer.height = img.height;
                bctx.drawImage(img, 0, 0);
                document.getElementById('status').textContent =
                        `Map: ${mapName} - ${timestamp.toLocaleTimeString()}`;

                baseScale = computeBaseScale();
                if (!hadImage || shouldCenter) {
                    zoom = 1;
                    const fitScale = baseScale * zoom;
                    offsetX = (canvas.width - buffer.width * fitScale) / 2;
                    offsetY = (canvas.height - buffer.height * fitScale) / 2;
                } else if (anchor) {
                    zoom = clampZoom(zoom);
                    restoreAnchor(anchor);
                }
                draw();
            }

            function refresh() {
                const img = new Image();
                img.src = `${IMAGE_ENDPOINT}?map=${encodeURIComponent(mapName)}&t=${Date.now()}`;
                img.onload = () => {
                    if (isInteracting) {
                        pendingImage = img;
                        pendingTimestamp = new Date();
                        return;
                    }
                    applyImage(img, new Date());
                };
            }

            function applyZoom(targetZoom, focus) {
                if (!buffer.width) return;
                const prevScale = baseScale * zoom;
                const focusPoint = focus || { x: canvas.width / 2, y: canvas.height / 2 };
                const imgX = (focusPoint.x - offsetX) / prevScale;
                const imgY = (focusPoint.y - offsetY) / prevScale;

                zoom = clampZoom(targetZoom);
                const nextScale = baseScale * zoom;
                offsetX = focusPoint.x - imgX * nextScale;
                offsetY = focusPoint.y - imgY * nextScale;
                draw();
            }

            function distance(p1, p2) {
                const dx = p1.x - p2.x, dy = p1.y - p2.y;
                return Math.hypot(dx, dy);
            }

            function pointerCenter() {
                const pts = Array.from(pointers.values());
                return {
                    x: (pts[0].x + pts[1].x) / 2,
                    y: (pts[0].y + pts[1].y) / 2
                };
            }

            function onPointerDown(e) {
                e.preventDefault();
                canvas.setPointerCapture(e.pointerId);
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                isInteracting = true;
                if (pointers.size === 1) {
                    lastPan = { x: e.clientX, y: e.clientY };
                } else if (pointers.size === 2) {
                    const pts = Array.from(pointers.values());
                    pinchStartDist = distance(pts[0], pts[1]);
                    pinchStartZoom = zoom;
                    lastPan = null; // disable panning during pinch
                }
            }

            function onPointerMove(e) {
                if (!pointers.has(e.pointerId)) return;
                e.preventDefault();
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                if (pointers.size === 2) {
                    const pts = Array.from(pointers.values());
                    const dist = distance(pts[0], pts[1]);
                    if (pinchStartDist) {
                        const factor = dist / pinchStartDist;
                        applyZoom(pinchStartZoom * factor, pointerCenter());
                        hasUserInteracted = true;
                    }
                } else if (pointers.size === 1 && zoom > 1) {
                    const pt = Array.from(pointers.values())[0];
                    if (lastPan) {
                        offsetX += (pt.x - lastPan.x);
                        offsetY += (pt.y - lastPan.y);
                        clampOffsets(baseScale * zoom);
                        draw();
                        hasUserInteracted = true;
                    }
                    lastPan = { x: pt.x, y: pt.y };
                }
            }

            function endPointer(e) {
                pointers.delete(e.pointerId);
                pinchStartDist = null;
                if (pointers.size === 1) {
                    const remaining = Array.from(pointers.values())[0];
                    lastPan = { x: remaining.x, y: remaining.y };
                } else {
                    lastPan = null;
                }
                if (pointers.size === 0) {
                    isInteracting = false;
                    if (pendingImage) {
                        const img = pendingImage;
                        const ts = pendingTimestamp || new Date();
                        pendingImage = null;
                        pendingTimestamp = null;
                        applyImage(img, ts);
                    }
                }
            }

            function start() {
                resize();
                refresh();
                timer = setInterval(refresh, REFRESH_MS);
                window.addEventListener('resize', resize);
                window.addEventListener('orientationchange', resize);
            }

            document.getElementById('homeBtn').onclick = () =>
                window.location.href = buildIndex(null);

            /* -------- BOOT -------- */
            mapName = getMapParam();
            if (!mapName) {
                document.getElementById('mapPage').style.display = 'none';
                document.getElementById('listPage').style.display = 'flex';
                setViewportMode('list');
                loadMapList();
            } else {
                document.getElementById('listPage').style.display = 'none';
                document.getElementById('mapPage').style.display = 'block';
                setViewportMode('map');
                start();
            }

            canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
            canvas.addEventListener('pointermove', onPointerMove, { passive: false });
            canvas.addEventListener('pointerup', endPointer);
            canvas.addEventListener('pointercancel', endPointer);
        </script>
    </body>
</html>


